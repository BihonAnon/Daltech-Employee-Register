/**
 * Created by Alexander Nuikin (nukisman@gmail.com) on 09.10.15.
 */
var Code = require('code');
var expect = Code.expect;

var when = require('when')
var _ = require('lodash')

var testRunner = require('mocha')

var Test = function (doneHandler) {
    var self = this
    if (typeof doneHandler !== 'function') {
        throw new Error('doneHandler must be a Function(error)')
    }
    this.doneHandler = doneHandler
    this.ctx = { // test context (shared request context)
        log: function () {
            log(self, _.toArray(arguments))
        }
    }
    this.reqCtx = {} // request context
    clearReqCtx(this)
    this.promise = when.resolve('Test initialized')
}

/** Test runner related functions **/

Test.before = testRunner.before
Test.beforeEach = testRunner.beforeEach
Test.after = testRunner.after
Test.afterEach = testRunner.afterEach

Test.describe = Test.suite = testRunner.describe;

Test.it = Test.case = function (name, body) {
    testRunner.it(name, function (done) {
        var test = new Test(done)
        body(test)
        test.done()
    })
}

/**
 * Promise-related methods
 */

Test.prototype.then = function (handler) {
    var self = this
    self.promise = self.promise
        .then(handler)
    return self
}

Test.prototype.catch = function (handler) {
    var self = this
    self.promise = self.promise
        .catch(handler)
    return self
}

Test.prototype.delay = function (ms, msg) {
    var self = this
    self.promise = self.promise
        .then(function () {
            log(self, 'Test delay ' + ms + 'ms' + (msg ? ': ' + msg : ''))
        })
        .delay(ms)
    return self
}

Test.prototype.done = function () {
    var self = this
    self.promise
        .then(function () {
            expectDefaultsIfNeed(self)
        })
        .done(function (value) {
            self.doneHandler()
        }, function (err) {
            print(self, 'FAIL', true) // TODO: replace '<indent>FAIL: ...' by '--><indentRest>...'
            //console.log('err:', err)
            if (err.expected && err.actual) {
                var errPrefix = err.message.substr(0, err.message.indexOf(':'))
                var maxLen = 100
                err.message = errPrefix
                    + ': Expected ' + maxString(quote(err.expected), maxLen)
                    + ' but was ' + maxString(quote(err.actual), maxLen)
            }
            self.doneHandler(err)
        })
    return self
}

/**  HTTP Request **/

Test.doHapiInjectRequest = function (params) {
    //console.log('doRequest:', params)
    return when.promise(function (resolve, reject) {
        Test.hapiServer.inject(params, function (res) {
            resolve(res)
        })
    })
}

Test.doRequest = Test.doHapiInjectRequest

Test.prototype.req = function (method, params) {
    //console.log('req:', method, params)
    var self = this
    self.promise = self.promise
        .then(function (value) {
            expectDefaultsIfNeed(self)
            clearReqCtx(self)
            if (_.isFunction(params)) {
                self.reqCtx.req = params(self.ctx)
            } else if (_.isObject(params)) {
                self.reqCtx.req = params
            } else {
                throw new Error('params must be object or function: ' + (typeof params), params)
            }
            self.reqCtx.req.method = method
            self.reqCtx.req.payload = self.reqCtx.req.payload || {} // TODO: Fix on server, not there!!!
            return Test.doRequest(self.reqCtx.req)
                .then(function (res) {
                    self.reqCtx.res = res
                    self.reqCtx.payloadProcessed = res.payload
                })
        })
    return self
}

function method(method) {
    return function (params) {
        return this.req(method, params)
    }
}

Test.prototype.head = method('HEAD') // url, headers

Test.prototype.get = method('GET') // url, headers

Test.prototype.post = method('POST') // url, payload, headers

Test.prototype.put = method('PUT') // url, payload, headers

Test.prototype.patch = method('PATCH') // url, payload, headers

Test.prototype.delete = method('DELETE') // url, payload, headers

Test.prototype.options = method('OPTIONS') // url, payload, headers

/** HTTP Response **/

Test.prototype.do = function (use) {
    var self = this
    self.promise = self.promise
        .then(function (res) {
            return use(self.ctx, self.reqCtx.payloadProcessed, self.reqCtx.res)
        })
    return self
}

Test.prototype.expect = function (use) {
    var self = this
    self.promise = self.promise
        .then(function (x) {
            self.reqCtx.defaultExpected = false
            return x
        })
    return self
        .do(use)
}

Test.prototype.status = function (statusCodeExpected) {
    var self = this
    return this
        .expect(function (ctx, payloadProcessed, res) {
            statusCodeExpected = unfunc(statusCodeExpected)
            self.reqCtx.expected.statusCode = statusCodeExpected
            expect(res.statusCode, 'StatusCode').to.be.equal(statusCodeExpected)
        })
}

Test.prototype.headers = function (someHeadersExpected) {
    var self = this
    return this
        .expect(function (ctx, payloadProcessed, res) {
            someHeadersExpected = unfunc(someHeadersExpected)
            expect(res.headers, 'Headers').contains(someHeadersExpected)
        })
}

Test.prototype.payload = function (statusExpected, payloadExpected) {
    var self = this
    if (!payloadExpected) {
        payloadExpected = statusExpected
        statusExpected = 200
    }
    return this
        .status(statusExpected)
        .expect(function (ctx, payloadProcessed, res) {
            if (payloadExpected) {
                payloadExpected = unfunc(payloadExpected)
                expect(res.payload, 'Payload').to.be.equal(payloadExpected)
            }
        })
}

Test.prototype.text = function (contentType) {
    var self = this
    return this
        .headers({'content-type': contentType || 'text/*; charset=utf-8'})
}

Test.prototype.processPayload = function (processPayload) {
    var self = this
    return this
        .do(function () {
            self.reqCtx.payloadProcessed = processPayload(self.ctx, self.reqCtx.payloadProcessed)
        })
}

Test.prototype.json = function (statusExpected, jsonExpected) {
    var self = this
    if (!jsonExpected) {
        jsonExpected = statusExpected
        statusExpected = 200
    }
    return this
        .status(statusExpected)
        .headers({'content-type': 'application/json; charset=utf-8'})
        .processPayload((ctx, payload) => JSON.parse(payload))
        .expect(function (ctx, payloadProcessed, res) {
            jsonExpected = unfunc(jsonExpected)
            if (jsonExpected) {
                expect(self.reqCtx.payloadProcessed, 'JSON Payload').contains(jsonExpected)
            }
        })
}

/** Utilities **/

Test.indent = _.repeat(' ', 8)

Test.log = function () {
    var args = _.toArray(arguments)
    args[0] = Test.indent + args[0]
    console.log.apply(console, args)
}

Test.prototype.log = function () {
    var msgs = _.toArray(arguments)
    var self = this
    return this
        .do(function () {
            expectDefaultsIfNeed(self)
            log(self, msgs)
        })
}

// TODO: print by default, hide by demand
Test.prototype.print = function (msg, printResHeaders) {
    var args = _.toArray(arguments)
    var self = this
    return this
        .do(function () {
            args.unshift(self)
            print.apply(null, args)
        })
}

/** Private functions **/

function log(test, msgs) {
    if (!_.isArray(msgs)) msgs = [msgs]
    msgs[0] = Test.indent + msgs[0]
    console.log.apply(console, msgs)
}

function clearReqCtx(test) {
    test.reqCtx = {}
    test.reqCtx.req = null
    test.reqCtx.res = null
    test.reqCtx.printed = false
    test.reqCtx.defaultExpected = true
    test.reqCtx.expected = {}
    test.reqCtx.payloadProcessed = null
}

function expectDefaultsIfNeed(test) {
    if (test.reqCtx.defaultExpected && test.reqCtx.res) { // there was previous request
        expect(test.reqCtx.res.statusCode, 'Status').equal(200)
        expect(test.reqCtx.res.headers).to.be.object()
        expect(test.reqCtx.res.headers['content-type'], 'Content-type').to.be.equal('application/json; charset=utf-8')
        expect(test.reqCtx.res.payload, 'Payload').to.be.a.string()
    }
}

function print(test, prefix, printResHeaders) {
    //console.log('print:', test.reqCtx.printed)
    if (!test.reqCtx.printed) {
        test.reqCtx.printed = true
        printResHeaders = printResHeaders || false
        var message = ''
        if (prefix) {
            message += prefix + ':'
        }
        if (test.reqCtx.req) {
            message += (prefix ? ' ' : '')
                + test.reqCtx.req.method + ' '
                + test.reqCtx.req.url
                + (test.reqCtx.req.headers ? '\t' + JSON.stringify(test.reqCtx.req.headers) : '')
                + (test.reqCtx.req.payload
                        ? (Buffer.isBuffer(test.reqCtx.req.payload)
                            ? '  #  Buffer[' + test.reqCtx.req.payload.length + ']'
                            : '  #  ' + JSON.stringify(test.reqCtx.req.payload)
                    )
                        : ''
                )
        }
        if (test.reqCtx.res) {
            message += '\n' + Test.indent + '  '
                + test.reqCtx.res.statusCode + ': '
                + (printResHeaders && test.reqCtx.res.headers ? JSON.stringify(test.reqCtx.res.headers) + ': ' : '')
            //+ JSON.stringify(test.reqCtx.payloadProcessed || test.reqCtx.res.payload)
            var payload = test.reqCtx.payloadProcessed || test.reqCtx.res.payload
            if (_.isObject(payload)) {
                message += JSON.stringify(payload)
            } else {

                switch(test.reqCtx.res.statusCode) {
                    case 200:
                        message += payload
                        break
                    case 204:
                        message += 'No content'
                        break
                    default:
                        var obj
                        try {
                            obj = JSON.parse(payload)
                        } catch (e) {
                            test.log('Payload parse error:', e)
                        }
                        var unexpected = test.reqCtx.expected.statusCode !== test.reqCtx.res.statusCode
                        if (obj && obj.error) {
                            if (unexpected) {
                                if (obj.stack) {
                                    message += `\t${Test.indent}Error: ${test.reqCtx.res.statusCode}: ${obj.error}: ${obj.message}`
                                    message += `\n\n${obj.stack}\n`
                                }
                                message += `\n${Test.indent}Error: ${test.reqCtx.res.statusCode}: ${obj.error}: ${obj.message}`
                            } else {
                                message += `${obj.error}: ${obj.message}`
                            }
                        } else {
                            message += payload
                        }
                }
            }
        }
        log(test, message)
    }
}

function quote(value) {
    switch (typeof value) {
        case "string":
            return '"' + value + '"'
        case "object":
            return JSON.stringify(value)
        default:
            return '' + value
    }
}

function maxString(str, len) {
    var infix = "..."
    if (str.length > len + infix.length) {
        var shift = (len - infix.length) / 2 + 1
        return str.substr(0, shift) + infix + str.substr(-shift) + ' (' + str.length + 'chars)'
    } else {
        return str
    }
}

function unfunc(funcOrValue, self) {
    return typeof funcOrValue == 'function' ? funcOrValue.apply(self, []) : funcOrValue
}

module.exports = Test